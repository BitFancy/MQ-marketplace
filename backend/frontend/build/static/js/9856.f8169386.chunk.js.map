{"version":3,"file":"static/js/9856.f8169386.chunk.js","mappings":"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","sources":["../node_modules/@ethereumjs/common/src/common.ts","../node_modules/@ethereumjs/common/src/eips/index.ts","../node_modules/@ethereumjs/common/src/enums.ts","../node_modules/@ethereumjs/common/src/hardforks/index.ts","../node_modules/@ethereumjs/common/src/index.ts","../node_modules/@ethereumjs/common/src/utils.ts","../node_modules/@ethereumjs/tx/src/baseTransaction.ts","../node_modules/@ethereumjs/tx/src/eip1559Transaction.ts","../node_modules/@ethereumjs/tx/src/eip2930Transaction.ts","../node_modules/@ethereumjs/tx/src/fromRpc.ts","../node_modules/@ethereumjs/tx/src/index.ts","../node_modules/@ethereumjs/tx/src/legacyTransaction.ts","../node_modules/@ethereumjs/tx/src/transactionFactory.ts","../node_modules/@ethereumjs/tx/src/types.ts","../node_modules/@ethereumjs/tx/src/util.ts"],"sourcesContent":["import { TypeOutput, intToBuffer, toType } from '@ethereumjs/util'\nimport { buf as crc32Buffer } from 'crc-32'\nimport { EventEmitter } from 'events'\n\nimport * as goerli from './chains/goerli.json'\nimport * as mainnet from './chains/mainnet.json'\nimport * as rinkeby from './chains/rinkeby.json'\nimport * as ropsten from './chains/ropsten.json'\nimport * as sepolia from './chains/sepolia.json'\nimport { EIPs } from './eips'\nimport { Chain, CustomChain, Hardfork } from './enums'\nimport { hardforks as HARDFORK_SPECS } from './hardforks'\nimport { parseGethGenesis } from './utils'\n\nimport type { ConsensusAlgorithm, ConsensusType } from './enums'\nimport type {\n  BootstrapNodeConfig,\n  CasperConfig,\n  ChainConfig,\n  ChainName,\n  ChainsConfig,\n  CliqueConfig,\n  CommonOpts,\n  CustomCommonOpts,\n  EthashConfig,\n  GenesisBlockConfig,\n  GethConfigOpts,\n  HardforkConfig,\n} from './types'\nimport type { BigIntLike } from '@ethereumjs/util'\n\ntype HardforkSpecKeys = keyof typeof HARDFORK_SPECS\ntype HardforkSpecValues = typeof HARDFORK_SPECS[HardforkSpecKeys]\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nexport class Common extends EventEmitter {\n  readonly DEFAULT_HARDFORK: string | Hardfork\n\n  private _chainParams: ChainConfig\n  private _hardfork: string | Hardfork\n  private _eips: number[] = []\n  private _customChains: ChainConfig[]\n\n  private HARDFORK_CHANGES: [HardforkSpecKeys, HardforkSpecValues][]\n\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `@ethereumjs/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(\n    chainParamsOrName: Partial<ChainConfig> | CustomChain,\n    opts: CustomCommonOpts = {}\n  ): Common {\n    const baseChain = opts.baseChain ?? 'mainnet'\n    const standardChainParams = { ...Common._getChainParams(baseChain) }\n    standardChainParams['name'] = 'custom-chain'\n\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common({\n        chain: {\n          ...standardChainParams,\n          ...chainParamsOrName,\n        },\n        ...opts,\n      })\n    } else {\n      if (chainParamsOrName === CustomChain.PolygonMainnet) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMainnet,\n            chainId: 137,\n            networkId: 137,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.PolygonMumbai) {\n        return Common.custom(\n          {\n            name: CustomChain.PolygonMumbai,\n            chainId: 80001,\n            networkId: 80001,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumRinkebyTestnet,\n            chainId: 421611,\n            networkId: 421611,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.ArbitrumOne) {\n        return Common.custom(\n          {\n            name: CustomChain.ArbitrumOne,\n            chainId: 42161,\n            networkId: 42161,\n          },\n          opts\n        )\n      }\n      if (chainParamsOrName === CustomChain.xDaiChain) {\n        return Common.custom(\n          {\n            name: CustomChain.xDaiChain,\n            chainId: 100,\n            networkId: 100,\n          },\n          opts\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticKovan) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticKovan,\n            chainId: 69,\n            networkId: 69,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n\n      if (chainParamsOrName === CustomChain.OptimisticEthereum) {\n        return Common.custom(\n          {\n            name: CustomChain.OptimisticEthereum,\n            chainId: 10,\n            networkId: 10,\n          },\n          // Optimism has not implemented the London hardfork yet (targeting Q1.22)\n          { hardfork: Hardfork.Berlin, ...opts }\n        )\n      }\n      throw new Error(`Custom chain ${chainParamsOrName} not supported`)\n    }\n  }\n\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(\n    genesisJson: any,\n    { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }: GethConfigOpts\n  ): Common {\n    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge)\n    const common = new Common({\n      chain: genesisParams.name ?? 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork ?? genesisParams.hardfork,\n    })\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash)\n    }\n    return common\n  }\n\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId: bigint): boolean {\n    const initializedChains = this._getInitializedChains()\n    return Boolean((initializedChains['names'] as ChainName)[chainId.toString()])\n  }\n\n  private static _getChainParams(\n    chain: string | number | Chain | bigint,\n    customChains?: ChainConfig[]\n  ): ChainConfig {\n    const initializedChains = this._getInitializedChains(customChains)\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString()\n\n      if ((initializedChains['names'] as ChainName)[chain]) {\n        const name: string = (initializedChains['names'] as ChainName)[chain]\n        return initializedChains[name] as ChainConfig\n      }\n\n      throw new Error(`Chain with ID ${chain} not supported`)\n    }\n\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain] as ChainConfig\n    }\n\n    throw new Error(`Chain with name ${chain} not supported`)\n  }\n\n  constructor(opts: CommonOpts) {\n    super()\n    this._customChains = opts.customChains ?? []\n    this._chainParams = this.setChain(opts.chain)\n    this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? Hardfork.Merge\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [\n      hf.name as HardforkSpecKeys,\n      HARDFORK_SPECS[hf.name as HardforkSpecKeys],\n    ])\n    this._hardfork = this.DEFAULT_HARDFORK\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork)\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips)\n    }\n  }\n\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain: string | number | Chain | bigint | object): ChainConfig {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains)\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error(\n          'Chain must be a string, number, or bigint when initialized with customChains passed in'\n        )\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes']\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`)\n        }\n      }\n      this._chainParams = chain as ChainConfig\n    } else {\n      throw new Error('Wrong input format')\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`)\n      }\n    }\n    return this._chainParams\n  }\n\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork: string | Hardfork): void {\n    let existing = false\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork\n          this.emit('hardforkChanged', hardfork)\n        }\n        existing = true\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`)\n    }\n  }\n\n  /**\n   * Returns the hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n   * @param timestamp: timestamp in seconds at which block was/is to be minted\n   * @returns The name of the HF\n   */\n  getHardforkByBlockNumber(\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): string {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    td = toType(td, TypeOutput.BigInt)\n    timestamp = toType(timestamp, TypeOutput.Number)\n\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(\n      (hf) =>\n        hf.block !== null || (hf.ttd !== null && hf.ttd !== undefined) || hf.timestamp !== undefined\n    )\n    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    const doubleTTDHF = hfs\n      .slice(mergeIndex + 1)\n      .findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`)\n    }\n\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(\n      (hf) =>\n        (hf.block !== null && hf.block > blockNumber) ||\n        (timestamp !== undefined && Number(hf.timestamp) > timestamp)\n    )\n\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0')\n    }\n\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs\n        .slice(0, hfIndex)\n        .reverse()\n        .findIndex((hf) => hf.block !== null || hf.ttd !== undefined)\n      hfIndex = hfIndex - stepBack\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex = hfIndex - 1\n\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd!) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1\n      }\n    } else {\n      if (mergeIndex >= 0 && td !== undefined && td !== null) {\n        if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd!) > td) {\n          throw Error('Maximum HF determined by total difficulty is lower than the block number HF')\n        } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd!) <= td) {\n          throw Error('HF determined by block number is lower than the minimum total difficulty HF')\n        }\n      }\n    }\n\n    const hfStartIndex = hfIndex\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex++) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (\n        hfs[hfIndex].block !== hfs[hfIndex + 1].block ||\n        hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp\n      ) {\n        break\n      }\n    }\n\n    if (timestamp) {\n      const minTimeStamp = hfs\n        .slice(0, hfStartIndex)\n        .reduce((acc: number, hf: HardforkConfig) => Math.max(Number(hf.timestamp ?? '0'), acc), 0)\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`)\n      }\n\n      const maxTimeStamp = hfs\n        .slice(hfIndex + 1)\n        .reduce(\n          (acc: number, hf: HardforkConfig) => Math.min(Number(hf.timestamp ?? timestamp), acc),\n          timestamp\n        )\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`)\n      }\n    }\n    const hardfork = hfs[hfIndex]\n    return hardfork.name\n  }\n\n  /**\n   * Sets a new hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td\n   * @param timestamp\n   * @returns The name of the HF set\n   */\n  setHardforkByBlockNumber(\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): string {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp)\n    this.setHardfork(hardfork)\n    return hardfork\n  }\n\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  _getHardfork(hardfork: string | Hardfork): HardforkConfig | null {\n    const hfs = this.hardforks()\n    for (const hf of hfs) {\n      if (hf['name'] === hardfork) return hf\n    }\n    return null\n  }\n\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips: number[] = []) {\n    for (const eip of eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`)\n      }\n      const minHF = this.gteHardfork(EIPs[eip]['minimumHardfork'])\n      if (!minHF) {\n        throw new Error(\n          `${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`\n        )\n      }\n      if (EIPs[eip].requiredEIPs !== undefined) {\n        for (const elem of EIPs[eip].requiredEIPs) {\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`)\n          }\n        }\n      }\n    }\n    this._eips = eips\n  }\n\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter if taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic: string, name: string): bigint {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value\n    for (const eip of this._eips) {\n      value = this.paramByEIP(topic, name, eip)\n      if (value !== undefined) return value\n    }\n    return this.paramByHardfork(topic, name, this._hardfork)\n  }\n\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic: string, name: string, hardfork: string | Hardfork): bigint {\n    let value = null\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF file (e.g. berlin.json)\n      if ('eips' in hfChanges[1]) {\n        const hfEIPs = hfChanges[1]['eips']\n        for (const eip of hfEIPs) {\n          const valueEIP = this.paramByEIP(topic, name, eip)\n          value = typeof valueEIP === 'bigint' ? valueEIP : value\n        }\n        // Parameter-inlining HF file (e.g. istanbul.json)\n      } else {\n        if (hfChanges[1][topic] === undefined) {\n          throw new Error(`Topic ${topic} not defined`)\n        }\n        if (hfChanges[1][topic][name] !== undefined) {\n          value = hfChanges[1][topic][name].v\n        }\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return BigInt(value ?? 0)\n  }\n\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  paramByEIP(topic: string, name: string, eip: number): bigint | undefined {\n    if (!(eip in EIPs)) {\n      throw new Error(`${eip} not supported`)\n    }\n\n    const eipParams = EIPs[eip]\n    if (!(topic in eipParams)) {\n      throw new Error(`Topic ${topic} not defined`)\n    }\n    if (eipParams[topic][name] === undefined) {\n      return undefined\n    }\n    const value = eipParams[topic][name].v\n    return BigInt(value)\n  }\n\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(\n    topic: string,\n    name: string,\n    blockNumber: BigIntLike,\n    td?: BigIntLike,\n    timestamp?: BigIntLike\n  ): bigint {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp)\n    return this.paramByHardfork(topic, name, hardfork)\n  }\n\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip: number): boolean {\n    if (this.eips().includes(eip)) {\n      return true\n    }\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if (this.gteHardfork(hf['name']) && 'eips' in hf) {\n        if ((hf['eips'] as number[]).includes(eip)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(hardfork: string | Hardfork | null, blockNumber: BigIntLike): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const hfBlock = this.hardforkBlock(hardfork)\n    if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber: BigIntLike): boolean {\n    return this.hardforkIsActiveOnBlock(null, blockNumber)\n  }\n\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(hardfork1: string | Hardfork | null, hardfork2: string | Hardfork): boolean {\n    hardfork1 = hardfork1 ?? this._hardfork\n    const hardforks = this.hardforks()\n\n    let posHf1 = -1,\n      posHf2 = -1\n    let index = 0\n    for (const hf of hardforks) {\n      if (hf['name'] === hardfork1) posHf1 = index\n      if (hf['name'] === hardfork2) posHf2 = index\n      index += 1\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1\n  }\n\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork: string | Hardfork): boolean {\n    return this.hardforkGteHardfork(null, hardfork)\n  }\n\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  hardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const block = this._getHardfork(hardfork)?.['block']\n    if (block === undefined || block === null) {\n      return null\n    }\n    return BigInt(block)\n  }\n\n  hardforkTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const timestamp = this._getHardfork(hardfork)?.['timestamp']\n    if (timestamp === undefined || timestamp === null) {\n      return null\n    }\n    return BigInt(timestamp)\n  }\n\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  eipBlock(eip: number): bigint | null {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      const hf = hfChanges[1]\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (hf['eips'].includes(eip)) {\n          return this.hardforkBlock(hfChanges[0])\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  hardforkTTD(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const ttd = this._getHardfork(hardfork)?.['ttd']\n    if (ttd === undefined || ttd === null) {\n      return null\n    }\n    return BigInt(ttd)\n  }\n\n  /**\n   * True if block number provided is the hardfork (given or set) change block\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isHardforkBlock(blockNumber: BigIntLike, hardfork?: string | Hardfork): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const block = this.hardforkBlock(hardfork)\n    return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  nextHardforkBlockOrTimestamp(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    const hfs = this.hardforks()\n    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork)\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === Hardfork.Merge) {\n      hfIndex -= 1\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      return null\n    }\n\n    let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block\n    currHfTimeOrBlock =\n      currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined\n        ? Number(currHfTimeOrBlock)\n        : null\n\n    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {\n      let hfTimeOrBlock = hf.timestamp ?? hf.block\n      hfTimeOrBlock =\n        hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null\n      return (\n        hf.name !== Hardfork.Merge &&\n        hfTimeOrBlock !== null &&\n        hfTimeOrBlock !== undefined &&\n        hfTimeOrBlock !== currHfTimeOrBlock\n      )\n    })\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      return null\n    }\n\n    const nextHfBlock = nextHf.timestamp ?? nextHf.block\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      return null\n    }\n\n    return BigInt(nextHfBlock)\n  }\n\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if not available\n   * @deprecated\n   */\n  nextHardforkBlock(hardfork?: string | Hardfork): bigint | null {\n    hardfork = hardfork ?? this._hardfork\n    let hfBlock = this.hardforkBlock(hardfork)\n    // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n    // to find the nextHardforkBlock\n    if (hfBlock === null && hardfork === Hardfork.Merge) {\n      const hfs = this.hardforks()\n      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined)\n      if (mergeIndex < 0) {\n        throw Error(`Merge hardfork should have been found`)\n      }\n      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name)\n    }\n    if (hfBlock === null) {\n      return null\n    }\n    // Next fork block number or null if none available\n    // Logic: if accumulator is still null and on the first occurrence of\n    // a block greater than the current hfBlock set the accumulator,\n    // pass on the accumulator as the final result from this time on\n    const nextHfBlock = this.hardforks().reduce((acc: bigint | null, hf: HardforkConfig) => {\n      // We need to ignore the merge block in our next hardfork calc\n      const block = BigInt(\n        hf.block === null || (hf.ttd !== undefined && hf.ttd !== null) ? 0 : hf.block\n      )\n      // Typescript can't seem to follow that the hfBlock is not null at this point\n      return block > hfBlock! && acc === null ? block : acc\n    }, null)\n    return nextHfBlock\n  }\n\n  /**\n   * True if block number provided is the hardfork change block following the hardfork given or set\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isNextHardforkBlock(blockNumber: BigIntLike, hardfork?: string | Hardfork): boolean {\n    blockNumber = toType(blockNumber, TypeOutput.BigInt)\n    hardfork = hardfork ?? this._hardfork\n    const nextHardforkBlock = this.nextHardforkBlock(hardfork)\n\n    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber\n  }\n\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  _calcForkHash(hardfork: string | Hardfork, genesisHash: Buffer) {\n    let hfBuffer = Buffer.alloc(0)\n    let prevBlockOrTime = 0\n    for (const hf of this.hardforks()) {\n      const { block, timestamp, name } = hf\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp ?? block\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null\n\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (\n        typeof blockOrTime === 'number' &&\n        blockOrTime !== 0 &&\n        blockOrTime !== prevBlockOrTime &&\n        name !== Hardfork.Merge\n      ) {\n        const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, '0'), 'hex')\n        hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer])\n        prevBlockOrTime = blockOrTime\n      }\n\n      if (hf.name === hardfork) break\n    }\n    const inputBuffer = Buffer.concat([genesisHash, hfBuffer])\n\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    const forkhash = intToBuffer(crc32Buffer(inputBuffer) >>> 0).toString('hex')\n    return `0x${forkhash}`\n  }\n\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(hardfork?: string | Hardfork, genesisHash?: Buffer): string {\n    hardfork = hardfork ?? this._hardfork\n    const data = this._getHardfork(hardfork)\n    if (\n      data === null ||\n      (data?.block === null && data?.timestamp === undefined && data?.ttd === undefined)\n    ) {\n      const msg = 'No fork hash calculation possible for future hardfork'\n      throw new Error(msg)\n    }\n    if (data?.forkHash !== null && data?.forkHash !== undefined) {\n      return data.forkHash\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation')\n    return this._calcForkHash(hardfork, genesisHash)\n  }\n\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  hardforkForForkHash(forkHash: string): HardforkConfig | null {\n    const resArray = this.hardforks().filter((hf: HardforkConfig) => {\n      return hf.forkHash === forkHash\n    })\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null\n  }\n\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash: Buffer) {\n    for (const hf of this.hardforks()) {\n      const blockOrTime = hf.timestamp ?? hf.block\n      if (\n        (hf.forkHash === null || hf.forkHash === undefined) &&\n        ((blockOrTime !== null && blockOrTime !== undefined) || typeof hf.ttd !== 'undefined')\n      ) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash)\n      }\n    }\n  }\n\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis(): GenesisBlockConfig {\n    return this._chainParams.genesis\n  }\n\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks(): HardforkConfig[] {\n    return this._chainParams.hardforks\n  }\n\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes(): BootstrapNodeConfig[] {\n    return this._chainParams.bootstrapNodes\n  }\n\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks(): string[] {\n    return this._chainParams.dnsNetworks!\n  }\n\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork(): string | Hardfork {\n    return this._hardfork\n  }\n\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId(): bigint {\n    return BigInt(this._chainParams.chainId)\n  }\n\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName(): string {\n    return this._chainParams.name\n  }\n\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId(): bigint {\n    return BigInt(this._chainParams.networkId)\n  }\n\n  /**\n   * Returns the active EIPs\n   * @returns List of EIPs\n   */\n  eips(): number[] {\n    return this._eips\n  }\n\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType(): string | ConsensusType {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['type']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? this._chainParams['consensus']['type']\n  }\n\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm(): string | ConsensusAlgorithm {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        value = hfChanges[1]['consensus']['algorithm']\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return value ?? (this._chainParams['consensus']['algorithm'] as ConsensusAlgorithm)\n  }\n\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig(): { [key: string]: CliqueConfig | EthashConfig | CasperConfig } {\n    const hardfork = this.hardfork()\n\n    let value\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        value = hfChanges[1]['consensus'][hfChanges[1]['consensus']['algorithm']]\n      }\n      if (hfChanges[0] === hardfork) break\n    }\n    return (\n      value ?? this._chainParams['consensus'][this.consensusAlgorithm() as ConsensusAlgorithm] ?? {}\n    )\n  }\n\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy(): Common {\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this)\n    copy.removeAllListeners()\n    return copy\n  }\n\n  static _getInitializedChains(customChains?: ChainConfig[]): ChainsConfig {\n    const names: ChainName = {}\n    for (const [name, id] of Object.entries(Chain)) {\n      names[id] = name.toLowerCase()\n    }\n    const chains = { mainnet, ropsten, rinkeby, goerli, sepolia } as ChainsConfig\n    if (customChains) {\n      for (const chain of customChains) {\n        const { name } = chain\n        names[chain.chainId.toString()] = name\n        chains[name] = chain\n      }\n    }\n    chains.names = names\n    return chains\n  }\n}\n","export const EIPs: { [key: number]: any } = {\n  1153: require('./1153.json'),\n  1559: require('./1559.json'),\n  2315: require('./2315.json'),\n  2537: require('./2537.json'),\n  2565: require('./2565.json'),\n  2718: require('./2718.json'),\n  2929: require('./2929.json'),\n  2930: require('./2930.json'),\n  3074: require('./3074.json'),\n  3198: require('./3198.json'),\n  3529: require('./3529.json'),\n  3540: require('./3540.json'),\n  3541: require('./3541.json'),\n  3554: require('./3554.json'),\n  3607: require('./3607.json'),\n  3651: require('./3651.json'),\n  3670: require('./3670.json'),\n  3675: require('./3675.json'),\n  3855: require('./3855.json'),\n  3860: require('./3860.json'),\n  4345: require('./4345.json'),\n  4399: require('./4399.json'),\n  4844: require('./4844.json'),\n  4895: require('./4895.json'),\n  5133: require('./5133.json'),\n}\n","export enum Chain {\n  Mainnet = 1,\n  Ropsten = 3,\n  Rinkeby = 4,\n  Goerli = 5,\n  Sepolia = 11155111,\n}\n\nexport enum Hardfork {\n  Chainstart = 'chainstart',\n  Homestead = 'homestead',\n  Dao = 'dao',\n  TangerineWhistle = 'tangerineWhistle',\n  SpuriousDragon = 'spuriousDragon',\n  Byzantium = 'byzantium',\n  Constantinople = 'constantinople',\n  Petersburg = 'petersburg',\n  Istanbul = 'istanbul',\n  MuirGlacier = 'muirGlacier',\n  Berlin = 'berlin',\n  London = 'london',\n  ArrowGlacier = 'arrowGlacier',\n  GrayGlacier = 'grayGlacier',\n  MergeForkIdTransition = 'mergeForkIdTransition',\n  Merge = 'merge',\n  Shanghai = 'shanghai',\n  ShardingForkDev = 'shardingFork',\n}\n\nexport enum ConsensusType {\n  ProofOfStake = 'pos',\n  ProofOfWork = 'pow',\n  ProofOfAuthority = 'poa',\n}\n\nexport enum ConsensusAlgorithm {\n  Ethash = 'ethash',\n  Clique = 'clique',\n  Casper = 'casper',\n}\n\nexport enum CustomChain {\n  /**\n   * Polygon (Matic) Mainnet\n   *\n   * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)\n   */\n  PolygonMainnet = 'polygon-mainnet',\n\n  /**\n   * Polygon (Matic) Mumbai Testnet\n   *\n   * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)\n   */\n  PolygonMumbai = 'polygon-mumbai',\n\n  /**\n   * Arbitrum Rinkeby Testnet\n   *\n   * - [Documentation](https://developer.offchainlabs.com/docs/public_testnet)\n   */\n  ArbitrumRinkebyTestnet = 'arbitrum-rinkeby-testnet',\n\n  /**\n   * Arbitrum One - mainnet for Arbitrum roll-up\n   *\n   * - [Documentation](https://developer.offchainlabs.com/public-chains)\n   */\n  ArbitrumOne = 'arbitrum-one',\n\n  /**\n   * xDai EVM sidechain with a native stable token\n   *\n   * - [Documentation](https://www.xdaichain.com/)\n   */\n  xDaiChain = 'x-dai-chain',\n\n  /**\n   * Optimistic Kovan - testnet for Optimism roll-up\n   *\n   * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)\n   */\n  OptimisticKovan = 'optimistic-kovan',\n\n  /**\n   * Optimistic Ethereum - mainnet for Optimism roll-up\n   *\n   * - [Documentation](https://community.optimism.io/docs/developers/tutorials.html)\n   */\n  OptimisticEthereum = 'optimistic-ethereum',\n}\n","export const hardforks = {\n  chainstart: require('./chainstart.json'),\n  homestead: require('./homestead.json'),\n  dao: require('./dao.json'),\n  tangerineWhistle: require('./tangerineWhistle.json'),\n  spuriousDragon: require('./spuriousDragon.json'),\n  byzantium: require('./byzantium.json'),\n  constantinople: require('./constantinople.json'),\n  petersburg: require('./petersburg.json'),\n  istanbul: require('./istanbul.json'),\n  muirGlacier: require('./muirGlacier.json'),\n  berlin: require('./berlin.json'),\n  london: require('./london.json'),\n  shanghai: require('./shanghai.json'),\n  arrowGlacier: require('./arrowGlacier.json'),\n  grayGlacier: require('./grayGlacier.json'),\n  mergeForkIdTransition: require('./mergeForkIdTransition.json'),\n  merge: require('./merge.json'),\n  shardingFork: require('./sharding.json'),\n}\n","export * from './common'\nexport * from './enums'\nexport * from './types'\nexport * from './utils'\n","import { intToHex, isHexPrefixed, stripHexPrefix } from '@ethereumjs/util'\n\nimport { Hardfork } from './enums'\n\ntype ConfigHardfork =\n  | { name: string; block: null; timestamp: number }\n  | { name: string; block: number; timestamp?: number }\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\nfunction formatNonce(nonce: string): string {\n  if (!nonce || nonce === '0x0') {\n    return '0x0000000000000000'\n  }\n  if (isHexPrefixed(nonce)) {\n    return '0x' + stripHexPrefix(nonce).padStart(16, '0')\n  }\n  return '0x' + nonce.padStart(16, '0')\n}\n\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\nfunction parseGethParams(json: any, mergeForkIdPostMerge: boolean = true) {\n  const {\n    name,\n    config,\n    difficulty,\n    mixHash,\n    gasLimit,\n    coinbase,\n    baseFeePerGas,\n  }: {\n    name: string\n    config: any\n    difficulty: string\n    mixHash: string\n    gasLimit: string\n    coinbase: string\n    baseFeePerGas: string\n  } = json\n  let { extraData, timestamp, nonce }: { extraData: string; timestamp: string; nonce: string } =\n    json\n  const genesisTimestamp = Number(timestamp)\n  const { chainId }: { chainId: number } = config\n\n  // geth is not strictly putting empty fields with a 0x prefix\n  if (extraData === '') {\n    extraData = '0x'\n  }\n  // geth may use number for timestamp\n  if (!isHexPrefixed(timestamp)) {\n    timestamp = intToHex(parseInt(timestamp))\n  }\n  // geth may not give us a nonce strictly formatted to an 8 byte hex string\n  if (nonce.length !== 18) {\n    nonce = formatNonce(nonce)\n  }\n\n  // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n  // but have different configuration parameters in geth genesis parameters\n  if (config.eip155Block !== config.eip158Block) {\n    throw new Error(\n      'EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork'\n    )\n  }\n\n  const params = {\n    name,\n    chainId,\n    networkId: chainId,\n    genesis: {\n      timestamp,\n      gasLimit: parseInt(gasLimit), // geth gasLimit and difficulty are hex strings while ours are `number`s\n      difficulty: parseInt(difficulty),\n      nonce,\n      extraData,\n      mixHash,\n      coinbase,\n      baseFeePerGas,\n    },\n    hardfork: undefined as string | undefined,\n    hardforks: [] as ConfigHardfork[],\n    bootstrapNodes: [],\n    consensus:\n      config.clique !== undefined\n        ? {\n            type: 'poa',\n            algorithm: 'clique',\n            clique: {\n              // The recent geth genesis seems to be using blockperiodseconds\n              // and epochlength for clique specification\n              // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n              period: config.clique.period ?? config.clique.blockperiodseconds,\n              epoch: config.clique.epoch ?? config.clique.epochlength,\n            },\n          }\n        : {\n            type: 'pow',\n            algorithm: 'ethash',\n            ethash: {},\n          },\n  }\n\n  const forkMap: { [key: string]: { name: string; postMerge?: boolean; isTimestamp?: boolean } } = {\n    [Hardfork.Homestead]: { name: 'homesteadBlock' },\n    [Hardfork.Dao]: { name: 'daoForkBlock' },\n    [Hardfork.TangerineWhistle]: { name: 'eip150Block' },\n    [Hardfork.SpuriousDragon]: { name: 'eip155Block' },\n    [Hardfork.Byzantium]: { name: 'byzantiumBlock' },\n    [Hardfork.Constantinople]: { name: 'constantinopleBlock' },\n    [Hardfork.Petersburg]: { name: 'petersburgBlock' },\n    [Hardfork.Istanbul]: { name: 'istanbulBlock' },\n    [Hardfork.MuirGlacier]: { name: 'muirGlacierBlock' },\n    [Hardfork.Berlin]: { name: 'berlinBlock' },\n    [Hardfork.London]: { name: 'londonBlock' },\n    [Hardfork.MergeForkIdTransition]: { name: 'mergeForkBlock', postMerge: mergeForkIdPostMerge },\n    [Hardfork.Shanghai]: { name: 'shanghaiTime', postMerge: true, isTimestamp: true },\n    [Hardfork.ShardingForkDev]: { name: 'shardingForkTime', postMerge: true, isTimestamp: true },\n  }\n\n  // forkMapRev is the map from config field name to Hardfork\n  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n    acc[forkMap[elem].name] = elem\n    return acc\n  }, {} as { [key: string]: string })\n  const configHardforkNames = Object.keys(config).filter(\n    (key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null\n  )\n\n  params.hardforks = configHardforkNames\n    .map((nameBlock) => ({\n      name: forkMapRev[nameBlock],\n      block:\n        forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== 'number'\n          ? null\n          : config[nameBlock],\n      timestamp:\n        forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === 'number'\n          ? config[nameBlock]\n          : undefined,\n    }))\n    .filter((fork) => fork.block !== null || fork.timestamp !== undefined) as ConfigHardfork[]\n\n  params.hardforks.sort(function (a: ConfigHardfork, b: ConfigHardfork) {\n    return (a.block ?? Infinity) - (b.block ?? Infinity)\n  })\n\n  params.hardforks.sort(function (a: ConfigHardfork, b: ConfigHardfork) {\n    return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp)\n  })\n\n  if (config.terminalTotalDifficulty !== undefined) {\n    // Following points need to be considered for placement of merge hf\n    // - Merge hardfork can't be placed at genesis\n    // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n    // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n    //   necessary for e.g. withdrawals\n    const mergeConfig = {\n      name: Hardfork.Merge,\n      ttd: config.terminalTotalDifficulty,\n      block: null,\n    }\n\n    // Merge hardfork has to be placed before first hardfork that is dependent on merge\n    const postMergeIndex = params.hardforks.findIndex(\n      (hf: any) => forkMap[hf.name]?.postMerge === true\n    )\n    if (postMergeIndex !== -1) {\n      params.hardforks.splice(postMergeIndex, 0, mergeConfig as unknown as ConfigHardfork)\n    } else {\n      params.hardforks.push(mergeConfig as unknown as ConfigHardfork)\n    }\n  }\n\n  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined\n  params.hardfork = latestHardfork?.name\n  params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 })\n\n  return params\n}\n\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\nexport function parseGethGenesis(json: any, name?: string, mergeForkIdPostMerge?: boolean) {\n  try {\n    if (['config', 'difficulty', 'gasLimit', 'alloc'].some((field) => !(field in json))) {\n      throw new Error('Invalid format, expected geth genesis fields missing')\n    }\n    if (name !== undefined) {\n      json.name = name\n    }\n    return parseGethParams(json, mergeForkIdPostMerge)\n  } catch (e: any) {\n    throw new Error(`Error parsing parameters file: ${e.message}`)\n  }\n}\n","import { Chain, Common, Hardfork } from '@ethereumjs/common'\nimport {\n  Address,\n  MAX_INTEGER,\n  MAX_UINT64,\n  SECP256K1_ORDER_DIV_2,\n  bufferToBigInt,\n  bufferToHex,\n  ecsign,\n  publicToAddress,\n  toBuffer,\n  unpadBuffer,\n} from '@ethereumjs/util'\n\nimport { Capability } from './types'\nimport { checkMaxInitCodeSize } from './util'\n\nimport type {\n  AccessListEIP2930TxData,\n  AccessListEIP2930ValuesArray,\n  FeeMarketEIP1559TxData,\n  FeeMarketEIP1559ValuesArray,\n  JsonTx,\n  TxData,\n  TxOptions,\n  TxValuesArray,\n} from './types'\nimport type { BigIntLike } from '@ethereumjs/util'\n\ninterface TransactionCache {\n  hash: Buffer | undefined\n  dataFee?: {\n    value: bigint\n    hardfork: string | Hardfork\n  }\n}\n\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nexport abstract class BaseTransaction<TransactionObject> {\n  private readonly _type: number\n\n  public readonly nonce: bigint\n  public readonly gasLimit: bigint\n  public readonly to?: Address\n  public readonly value: bigint\n  public readonly data: Buffer\n\n  public readonly v?: bigint\n  public readonly r?: bigint\n  public readonly s?: bigint\n\n  public readonly common!: Common\n\n  protected cache: TransactionCache = {\n    hash: undefined,\n    dataFee: undefined,\n  }\n\n  protected readonly txOptions: TxOptions\n\n  /**\n   * List of tx type defining EIPs,\n   * e.g. 1559 (fee market) and 2930 (access lists)\n   * for FeeMarketEIP1559Transaction objects\n   */\n  protected activeCapabilities: number[] = []\n\n  /**\n   * The default chain the tx falls back to if no Common\n   * is provided and if the chain can't be derived from\n   * a passed in chainId (only EIP-2718 typed txs) or\n   * EIP-155 signature (legacy txs).\n   *\n   * @hidden\n   */\n  protected DEFAULT_CHAIN = Chain.Mainnet\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK: string | Hardfork = Hardfork.Merge\n\n  constructor(txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData, opts: TxOptions) {\n    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData\n    this._type = Number(bufferToBigInt(toBuffer(type)))\n\n    this.txOptions = opts\n\n    const toB = toBuffer(to === '' ? '0x' : to)\n    const vB = toBuffer(v === '' ? '0x' : v)\n    const rB = toBuffer(r === '' ? '0x' : r)\n    const sB = toBuffer(s === '' ? '0x' : s)\n\n    this.nonce = bufferToBigInt(toBuffer(nonce === '' ? '0x' : nonce))\n    this.gasLimit = bufferToBigInt(toBuffer(gasLimit === '' ? '0x' : gasLimit))\n    this.to = toB.length > 0 ? new Address(toB) : undefined\n    this.value = bufferToBigInt(toBuffer(value === '' ? '0x' : value))\n    this.data = toBuffer(data === '' ? '0x' : data)\n\n    this.v = vB.length > 0 ? bufferToBigInt(vB) : undefined\n    this.r = rB.length > 0 ? bufferToBigInt(rB) : undefined\n    this.s = sB.length > 0 ? bufferToBigInt(sB) : undefined\n\n    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s })\n\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64)\n\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true)\n\n    const createContract = this.to === undefined || this.to === null\n    const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false\n    const common = opts.common ?? this._getCommon()\n    if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {\n      checkMaxInitCodeSize(common, this.data.length)\n    }\n  }\n\n  /**\n   * Returns the transaction type.\n   *\n   * Note: legacy txs will return tx type `0`.\n   */\n  get type() {\n    return this._type\n  }\n\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilites` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  supports(capability: Capability) {\n    return this.activeCapabilities.includes(capability)\n  }\n\n  /**\n   * Checks if the transaction has the minimum amount of gas required\n   * (DataFee + TxFee + Creation Fee).\n   */\n  validate(): boolean\n  validate(stringError: false): boolean\n  validate(stringError: true): string[]\n  validate(stringError: boolean = false): boolean | string[] {\n    const errors = []\n\n    if (this.getBaseFee() > this.gasLimit) {\n      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`)\n    }\n\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature')\n    }\n\n    return stringError ? errors : errors.length === 0\n  }\n\n  protected _validateYParity() {\n    const { v } = this\n    if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {\n      const msg = this._errorMsg('The y-parity of the transaction should either be 0 or 1')\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.\n   * Reasoning: https://ethereum.stackexchange.com/a/55728\n   */\n  protected _validateHighS() {\n    const { s } = this\n    if (this.common.gteHardfork('homestead') && s !== undefined && s > SECP256K1_ORDER_DIV_2) {\n      const msg = this._errorMsg(\n        'Invalid Signature: s-values greater than secp256k1n/2 are considered invalid'\n      )\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  getBaseFee(): bigint {\n    const txFee = this.common.param('gasPrices', 'tx')\n    let fee = this.getDataFee()\n    if (txFee) fee += txFee\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      const txCreationFee = this.common.param('gasPrices', 'txCreation')\n      if (txCreationFee) fee += txCreationFee\n    }\n    return fee\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    const txDataZero = this.common.param('gasPrices', 'txDataZero')\n    const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero')\n\n    let cost = BigInt(0)\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero)\n    }\n\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      const dataLength = BigInt(Math.ceil(this.data.length / 32))\n      const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength\n      cost += initCodeCost\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  abstract getUpfrontCost(): bigint\n\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  toCreationAddress(): boolean {\n    return this.to === undefined || this.to.buf.length === 0\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of this transaction, in order.\n   *\n   * Use {@link BaseTransaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link BaseTransaction.getMessageToSign}.\n   */\n  abstract raw(): TxValuesArray | AccessListEIP2930ValuesArray | FeeMarketEIP1559ValuesArray\n\n  /**\n   * Returns the encoding of the transaction.\n   */\n  abstract serialize(): Buffer\n\n  // Returns the unsigned tx (hashed or raw), which is used to sign the transaction.\n  //\n  // Note: do not use code docs here since VS Studio is then not able to detect the\n  // comments from the inherited methods\n  abstract getMessageToSign(hashMessage: false): Buffer | Buffer[]\n  abstract getMessageToSign(hashMessage?: true): Buffer\n\n  abstract hash(): Buffer\n\n  abstract getMessageToVerifySignature(): Buffer\n\n  public isSigned(): boolean {\n    const { v, r, s } = this\n    if (v === undefined || r === undefined || s === undefined) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * Determines if the signature is valid\n   */\n  verifySignature(): boolean {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      const publicKey = this.getSenderPublicKey()\n      return unpadBuffer(publicKey).length !== 0\n    } catch (e: any) {\n      return false\n    }\n  }\n\n  /**\n   * Returns the sender's address\n   */\n  getSenderAddress(): Address {\n    return new Address(publicToAddress(this.getSenderPublicKey()))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  abstract getSenderPublicKey(): Buffer\n\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  sign(privateKey: Buffer): TransactionObject {\n    if (privateKey.length !== 32) {\n      const msg = this._errorMsg('Private key must be 32 bytes in length.')\n      throw new Error(msg)\n    }\n\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    let hackApplied = false\n    if (\n      this.type === 0 &&\n      this.common.gteHardfork('spuriousDragon') &&\n      !this.supports(Capability.EIP155ReplayProtection)\n    ) {\n      this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      hackApplied = true\n    }\n\n    const msgHash = this.getMessageToSign(true)\n    const { v, r, s } = ecsign(msgHash, privateKey)\n    const tx = this._processSignature(v, r, s)\n\n    // Hack part 2\n    if (hackApplied) {\n      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection)\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1)\n      }\n    }\n\n    return tx\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  abstract toJSON(): JsonTx\n\n  // Accept the v,r,s values from the `sign` method, and convert this into a TransactionObject\n  protected abstract _processSignature(v: bigint, r: Buffer, s: Buffer): TransactionObject\n\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  protected _getCommon(common?: Common, chainId?: BigIntLike) {\n    // Chain ID provided\n    if (chainId !== undefined) {\n      const chainIdBigInt = bufferToBigInt(toBuffer(chainId))\n      if (common) {\n        if (common.chainId() !== chainIdBigInt) {\n          const msg = this._errorMsg('The chain ID does not match the chain ID of Common')\n          throw new Error(msg)\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy()\n      } else {\n        if (Common.isSupportedChainId(chainIdBigInt)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK })\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return Common.custom(\n            {\n              name: 'custom-chain',\n              networkId: chainIdBigInt,\n              chainId: chainIdBigInt,\n            },\n            { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK }\n          )\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return (\n        common?.copy() ?? new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK })\n      )\n    }\n  }\n\n  /**\n   * Validates that an object with BigInt values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BigInt values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  protected _validateCannotExceedMaxInteger(\n    values: { [key: string]: bigint | undefined },\n    bits = 256,\n    cannotEqual = false\n  ) {\n    for (const [key, value] of Object.entries(values)) {\n      switch (bits) {\n        case 64:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_UINT64) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_UINT64) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`)\n              throw new Error(msg)\n            }\n          }\n          break\n        case 256:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          }\n          break\n        default: {\n          const msg = this._errorMsg('unimplemented bits value')\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n\n  protected static _validateNotArray(values: { [key: string]: any }) {\n    const txDataKeys = [\n      'nonce',\n      'gasPrice',\n      'gasLimit',\n      'to',\n      'value',\n      'data',\n      'v',\n      'r',\n      's',\n      'type',\n      'baseFee',\n      'maxFeePerGas',\n      'chainId',\n    ]\n    for (const [key, value] of Object.entries(values)) {\n      if (txDataKeys.includes(key)) {\n        if (Array.isArray(value)) {\n          throw new Error(`${key} cannot be an array`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public abstract errorStr(): string\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected abstract _errorMsg(msg: string): string\n\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  protected _getSharedErrorPostfix() {\n    let hash = ''\n    try {\n      hash = this.isSigned() ? bufferToHex(this.hash()) : 'not available (unsigned)'\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let isSigned = ''\n    try {\n      isSigned = this.isSigned().toString()\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let hf = ''\n    try {\n      hf = this.common.hardfork()\n    } catch (e: any) {\n      hf = 'error'\n    }\n\n    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `\n    postfix += `signed=${isSigned} hf=${hf}`\n\n    return postfix\n  }\n}\n","import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { AccessLists } from './util'\n\nimport type {\n  AccessList,\n  AccessListBuffer,\n  FeeMarketEIP1559TxData,\n  FeeMarketEIP1559ValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 2\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')\n\n/**\n * Typed transaction with a new gas fee market mechanism\n *\n * - TransactionType: 2\n * - EIP: [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)\n */\nexport class FeeMarketEIP1559Transaction extends BaseTransaction<FeeMarketEIP1559Transaction> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBuffer\n  public readonly AccessListJSON: AccessList\n  public readonly maxPriorityFeePerGas: bigint\n  public readonly maxFeePerGas: bigint\n\n  public readonly common: Common\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK = 'london'\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: FeeMarketEIP1559TxData, opts: TxOptions = {}) {\n    return new FeeMarketEIP1559Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized\n          .slice(0, 1)\n          .toString('hex')}`\n      )\n    }\n\n    const values = arrToBufArr(RLP.decode(serialized.slice(1)))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return FeeMarketEIP1559Transaction.fromValuesArray(values as any, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   */\n  public static fromValuesArray(values: FeeMarketEIP1559ValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 9 && values.length !== 12) {\n      throw new Error(\n        'Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).'\n      )\n    }\n\n    const [\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gasLimit,\n      to,\n      value,\n      data,\n      accessList,\n      v,\n      r,\n      s,\n    ] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s })\n\n    return new FeeMarketEIP1559Transaction(\n      {\n        chainId: bufferToBigInt(chainId),\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? [],\n        v: v !== undefined ? bufferToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Buffer)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: FeeMarketEIP1559TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    if (this.common.isActivatedEIP(1559) === false) {\n      throw new Error('EIP-1559 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.maxFeePerGas = bufferToBigInt(toBuffer(maxFeePerGas === '' ? '0x' : maxFeePerGas))\n    this.maxPriorityFeePerGas = bufferToBigInt(\n      toBuffer(maxPriorityFeePerGas === '' ? '0x' : maxPriorityFeePerGas)\n    )\n\n    this._validateCannotExceedMaxInteger({\n      maxFeePerGas: this.maxFeePerGas,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n\n    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n      const msg = this._errorMsg(\n        'maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)'\n      )\n      throw new Error(msg)\n    }\n\n    this._validateYParity()\n    this._validateHighS()\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    let cost = super.getDataFee()\n    cost += BigInt(AccessLists.getDataFeeEIP2930(this.accessList, this.common))\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: cost,\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   * @param baseFee The base fee of the block (will be set to 0 if not provided)\n   */\n  getUpfrontCost(baseFee: bigint = BigInt(0)): bigint {\n    const prio = this.maxPriorityFeePerGas\n    const maxBase = this.maxFeePerGas - baseFee\n    const inclusionFeePerGas = prio < maxBase ? prio : maxBase\n    const gasPrice = inclusionFeePerGas + baseFee\n    return this.gasLimit * gasPrice + this.value\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the EIP-1559 transaction, in order.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   *\n   * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.\n   */\n  raw(): FeeMarketEIP1559ValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.chainId),\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.maxPriorityFeePerGas),\n      bigIntToUnpaddedBuffer(this.maxFeePerGas),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-1559 transaction.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Buffer {\n    const base = this.raw()\n    return Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n  }\n\n  /**\n   * Returns the serialized unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage = true): Buffer {\n    const base = this.raw().slice(0, 9)\n    const message = Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n    if (hashMessage) {\n      return Buffer.from(keccak256(message))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(this.serialize()))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(this.serialize()))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Buffer {\n    return this.getMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    const msgHash = this.getMessageToVerifySignature()\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v! + BigInt(27), // Recover the 27 which was stripped from ecsign\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!)\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    const opts = { ...this.txOptions, common: this.common }\n\n    return FeeMarketEIP1559Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        maxFeePerGas: this.maxFeePerGas,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: v - BigInt(27), // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n\n    return {\n      chainId: bigIntToHex(this.chainId),\n      nonce: bigIntToHex(this.nonce),\n      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),\n      maxFeePerGas: bigIntToHex(this.maxFeePerGas),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n","import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { AccessLists } from './util'\n\nimport type {\n  AccessList,\n  AccessListBuffer,\n  AccessListEIP2930TxData,\n  AccessListEIP2930ValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 1\nconst TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')\n\n/**\n * Typed transaction with optional access lists\n *\n * - TransactionType: 1\n * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)\n */\nexport class AccessListEIP2930Transaction extends BaseTransaction<AccessListEIP2930Transaction> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBuffer\n  public readonly AccessListJSON: AccessList\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n\n  /**\n   * The default HF if the tx type is active on that HF\n   * or the first greater HF where the tx is active.\n   *\n   * @hidden\n   */\n  protected DEFAULT_HARDFORK = 'berlin'\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: AccessListEIP2930TxData, opts: TxOptions = {}) {\n    return new AccessListEIP2930Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized\n          .slice(0, 1)\n          .toString('hex')}`\n      )\n    }\n\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized.slice(1))))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return AccessListEIP2930Transaction.fromValuesArray(values as any, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   */\n  public static fromValuesArray(values: AccessListEIP2930ValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 8 && values.length !== 11) {\n      throw new Error(\n        'Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).'\n      )\n    }\n\n    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    const emptyAccessList: AccessList = []\n\n    return new AccessListEIP2930Transaction(\n      {\n        chainId: bufferToBigInt(chainId),\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? emptyAccessList,\n        v: v !== undefined ? bufferToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Buffer)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: AccessListEIP2930TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n    const { chainId, accessList, gasPrice } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    // EIP-2718 check is done in Common\n    if (!this.common.isActivatedEIP(2930)) {\n      throw new Error('EIP-2930 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.gasPrice = bufferToBigInt(toBuffer(gasPrice === '' ? '0x' : gasPrice))\n\n    this._validateCannotExceedMaxInteger({\n      gasPrice: this.gasPrice,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER')\n      throw new Error(msg)\n    }\n\n    this._validateYParity()\n    this._validateHighS()\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    let cost = super.getDataFee()\n    cost += BigInt(AccessLists.getDataFeeEIP2930(this.accessList, this.common))\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: cost,\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return cost\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   *\n   * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.\n   */\n  raw(): AccessListEIP2930ValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.chainId),\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-2930 transaction.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Buffer {\n    const base = this.raw()\n    return Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n  }\n\n  /**\n   * Returns the serialized unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage = true): Buffer {\n    const base = this.raw().slice(0, 8)\n    const message = Buffer.concat([\n      TRANSACTION_TYPE_BUFFER,\n      Buffer.from(RLP.encode(bufArrToArr(base as Buffer[]))),\n    ])\n    if (hashMessage) {\n      return Buffer.from(keccak256(message))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(this.serialize()))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(this.serialize()))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Buffer {\n    return this.getMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call this method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    const msgHash = this.getMessageToVerifySignature()\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v! + BigInt(27), // Recover the 27 which was stripped from ecsign\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!)\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    const opts = { ...this.txOptions, common: this.common }\n\n    return AccessListEIP2930Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: v - BigInt(27), // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n\n    return {\n      chainId: bigIntToHex(this.chainId),\n      nonce: bigIntToHex(this.nonce),\n      gasPrice: bigIntToHex(this.gasPrice),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      accessList: accessListJSON,\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail\n    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n","import { TypeOutput, setLengthLeft, toBuffer, toType } from '@ethereumjs/util'\n\nimport type { TxData } from './types'\n\nexport const normalizeTxParams = (_txParams: any): TxData => {\n  const txParams = Object.assign({}, _txParams)\n\n  txParams.gasLimit = toType(txParams.gasLimit ?? txParams.gas, TypeOutput.BigInt)\n  txParams.data = txParams.data === undefined ? txParams.input : txParams.data\n\n  // check and convert gasPrice and value params\n  txParams.gasPrice = txParams.gasPrice !== undefined ? BigInt(txParams.gasPrice) : undefined\n  txParams.value = txParams.value !== undefined ? BigInt(txParams.value) : undefined\n\n  // strict byte length checking\n  txParams.to =\n    txParams.to !== null && txParams.to !== undefined\n      ? setLengthLeft(toBuffer(txParams.to), 20)\n      : null\n\n  // Normalize the v/r/s values. If RPC returns '0x0', ensure v/r/s are set to `undefined` in the tx.\n  // If this is not done, then the transaction creation will throw, because `v` is `0`.\n  // Note: this still means that `isSigned` will return `false`.\n  // v/r/s values are `0x0` on networks like Optimism, where the tx is a system tx.\n  // For instance: https://optimistic.etherscan.io/tx/0xf4304cb09b3f58a8e5d20fec5f393c96ccffe0269aaf632cb2be7a8a0f0c91cc\n\n  txParams.v = txParams.v === '0x0' ? '0x' : txParams.v\n  txParams.r = txParams.r === '0x0' ? '0x' : txParams.r\n  txParams.s = txParams.s === '0x0' ? '0x' : txParams.s\n\n  if (txParams.v !== '0x') {\n    txParams.v = toType(txParams.v, TypeOutput.BigInt)\n  }\n\n  return txParams\n}\n","export { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nexport { AccessListEIP2930Transaction } from './eip2930Transaction'\nexport { Transaction } from './legacyTransaction'\nexport { TransactionFactory } from './transactionFactory'\nexport * from './types'\n","import { RLP } from '@ethereumjs/rlp'\nimport {\n  MAX_INTEGER,\n  arrToBufArr,\n  bigIntToHex,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  ecrecover,\n  toBuffer,\n  unpadBuffer,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\n\nimport { BaseTransaction } from './baseTransaction'\nimport { Capability } from './types'\n\nimport type { JsonTx, TxData, TxOptions, TxValuesArray } from './types'\nimport type { Common } from '@ethereumjs/common'\n\nconst TRANSACTION_TYPE = 0\n\nfunction meetsEIP155(_v: bigint, chainId: bigint) {\n  const v = Number(_v)\n  const chainIdDoubled = Number(chainId) * 2\n  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36\n}\n\n/**\n * An Ethereum non-typed (legacy) transaction\n */\nexport class Transaction extends BaseTransaction<Transaction> {\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }\n   *\n   * Notes:\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: TxData, opts: TxOptions = {}) {\n    return new Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`\n   */\n  public static fromSerializedTx(serialized: Buffer, opts: TxOptions = {}) {\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized))) as Buffer[]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input. Must be array')\n    }\n\n    return this.fromValuesArray(values, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    // If length is not 6, it has length 9. If v/r/s are empty Buffers, it is still an unsigned transaction\n    // This happens if you get the RLP data from `raw()`\n    if (values.length !== 6 && values.length !== 9) {\n      throw new Error(\n        'Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).'\n      )\n    }\n\n    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values\n\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    return new Transaction(\n      {\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        v,\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TRANSACTION_TYPE }, opts)\n\n    this.common = this._validateTxV(this.v, opts.common)\n\n    this.gasPrice = bufferToBigInt(toBuffer(txData.gasPrice === '' ? '0x' : txData.gasPrice))\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice })\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.common.gteHardfork('spuriousDragon')) {\n      if (!this.isSigned()) {\n        this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      } else {\n        // EIP155 spec:\n        // If block.number >= 2,675,000 and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36\n        // then when computing the hash of a transaction for purposes of signing or recovering\n        // instead of hashing only the first six elements (i.e. nonce, gasprice, startgas, to, value, data)\n        // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0.\n        // v and chain ID meet EIP-155 conditions\n        if (meetsEIP155(this.v!, this.common.chainId())) {\n          this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n        }\n      }\n    }\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers of the legacy transaction, in order.\n   *\n   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`\n   *\n   * For legacy txs this is also the correct format to add transactions\n   * to a block with {@link Block.fromValuesArray} (use the `serialize()` method\n   * for typed txs).\n   *\n   * For an unsigned tx this method returns the empty Buffer values\n   * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant\n   * representation have a look at {@link Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n      this.v !== undefined ? bigIntToUnpaddedBuffer(this.v) : Buffer.from([]),\n      this.r !== undefined ? bigIntToUnpaddedBuffer(this.r) : Buffer.from([]),\n      this.s !== undefined ? bigIntToUnpaddedBuffer(this.s) : Buffer.from([]),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the legacy transaction.\n   *\n   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`\n   *\n   * For an unsigned tx this method uses the empty Buffer values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link Transaction.getMessageToSign}.\n   */\n  serialize(): Buffer {\n    return Buffer.from(RLP.encode(bufArrToArr(this.raw())))\n  }\n\n  private _getMessageToSign() {\n    const values = [\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.gasPrice),\n      bigIntToUnpaddedBuffer(this.gasLimit),\n      this.to !== undefined ? this.to.buf : Buffer.from([]),\n      bigIntToUnpaddedBuffer(this.value),\n      this.data,\n    ]\n\n    if (this.supports(Capability.EIP155ReplayProtection)) {\n      values.push(bigIntToUnpaddedBuffer(this.common.chainId()))\n      values.push(unpadBuffer(toBuffer(0)))\n      values.push(unpadBuffer(toBuffer(0)))\n    }\n\n    return values\n  }\n\n  /**\n   * Returns the unsigned tx (hashed or raw), which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: the raw message message format for the legacy tx is not RLP encoded\n   * and you might need to do yourself with:\n   *\n   * ```javascript\n   * import { bufArrToArr } from '@ethereumjs/util'\n   * import { RLP } from '@ethereumjs/rlp'\n   * const message = tx.getMessageToSign(false)\n   * const serializedMessage = Buffer.from(RLP.encode(bufArrToArr(message))) // use this for the HW wallet input\n   * ```\n   *\n   * @param hashMessage - Return hashed message if set to true (default: true)\n   */\n  getMessageToSign(hashMessage: false): Buffer[]\n  getMessageToSign(hashMessage?: true): Buffer\n  getMessageToSign(hashMessage = true) {\n    const message = this._getMessageToSign()\n    if (hashMessage) {\n      return Buffer.from(keccak256(RLP.encode(bufArrToArr(message))))\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {\n      return this.cache.dataFee.value\n    }\n\n    if (Object.isFrozen(this)) {\n      this.cache.dataFee = {\n        value: super.getDataFee(),\n        hardfork: this.common.hardfork(),\n      }\n    }\n\n    return super.getDataFee()\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  hash(): Buffer {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('Cannot call hash method if transaction is not signed')\n      throw new Error(msg)\n    }\n\n    if (Object.isFrozen(this)) {\n      if (!this.cache.hash) {\n        this.cache.hash = Buffer.from(keccak256(RLP.encode(bufArrToArr(this.raw()))))\n      }\n      return this.cache.hash\n    }\n\n    return Buffer.from(keccak256(RLP.encode(bufArrToArr(this.raw()))))\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  getMessageToVerifySignature() {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('This transaction is not signed')\n      throw new Error(msg)\n    }\n    const message = this._getMessageToSign()\n    return Buffer.from(keccak256(RLP.encode(bufArrToArr(message))))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  getSenderPublicKey(): Buffer {\n    const msgHash = this.getMessageToVerifySignature()\n\n    const { v, r, s } = this\n\n    this._validateHighS()\n\n    try {\n      return ecrecover(\n        msgHash,\n        v!,\n        bigIntToUnpaddedBuffer(r!),\n        bigIntToUnpaddedBuffer(s!),\n        this.supports(Capability.EIP155ReplayProtection) ? this.common.chainId() : undefined\n      )\n    } catch (e: any) {\n      const msg = this._errorMsg('Invalid Signature')\n      throw new Error(msg)\n    }\n  }\n\n  /**\n   * Process the v, r, s values from the `sign` method of the base transaction.\n   */\n  protected _processSignature(v: bigint, r: Buffer, s: Buffer) {\n    if (this.supports(Capability.EIP155ReplayProtection)) {\n      v += this.common.chainId() * BigInt(2) + BigInt(8)\n    }\n\n    const opts = { ...this.txOptions, common: this.common }\n\n    return Transaction.fromTxData(\n      {\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        v,\n        r: bufferToBigInt(r),\n        s: bufferToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction.\n   */\n  toJSON(): JsonTx {\n    return {\n      nonce: bigIntToHex(this.nonce),\n      gasPrice: bigIntToHex(this.gasPrice),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: '0x' + this.data.toString('hex'),\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Validates tx's `v` value\n   */\n  private _validateTxV(_v?: bigint, common?: Common): Common {\n    let chainIdBigInt\n    const v = _v !== undefined ? Number(_v) : undefined\n    // Check for valid v values in the scope of a signed legacy tx\n    if (v !== undefined) {\n      // v is 1. not matching the EIP-155 chainId included case and...\n      // v is 2. not matching the classic v=27 or v=28 case\n      if (v < 37 && v !== 27 && v !== 28) {\n        throw new Error(\n          `Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`\n        )\n      }\n    }\n\n    // No unsigned tx and EIP-155 activated and chain ID included\n    if (\n      v !== undefined &&\n      v !== 0 &&\n      (!common || common.gteHardfork('spuriousDragon')) &&\n      v !== 27 &&\n      v !== 28\n    ) {\n      if (common) {\n        if (!meetsEIP155(BigInt(v), common.chainId())) {\n          throw new Error(\n            `Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`\n          )\n        }\n      } else {\n        // Derive the original chain ID\n        let numSub\n        if ((v - 35) % 2 === 0) {\n          numSub = 35\n        } else {\n          numSub = 36\n        }\n        // Use derived chain ID to create a proper Common\n        chainIdBigInt = BigInt(v - numSub) / BigInt(2)\n      }\n    }\n    return this._getCommon(common, chainIdBigInt)\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` gasPrice=${this.gasPrice}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return `${msg} (${this.errorStr()})`\n  }\n}\n","import { bufferToBigInt, fetchFromProvider, getProvider, toBuffer } from '@ethereumjs/util'\n\nimport { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nimport { AccessListEIP2930Transaction } from './eip2930Transaction'\nimport { normalizeTxParams } from './fromRpc'\nimport { Transaction } from './legacyTransaction'\n\nimport type {\n  AccessListEIP2930TxData,\n  FeeMarketEIP1559TxData,\n  TxData,\n  TxOptions,\n  TypedTransaction,\n} from './types'\n\nexport class TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  private constructor() {}\n\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n  public static fromTxData(\n    txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData,\n    txOptions: TxOptions = {}\n  ): TypedTransaction {\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return Transaction.fromTxData(<TxData>txData, txOptions)\n    } else {\n      const txType = Number(bufferToBigInt(toBuffer(txData.type)))\n      if (txType === 0) {\n        return Transaction.fromTxData(<TxData>txData, txOptions)\n      } else if (txType === 1) {\n        return AccessListEIP2930Transaction.fromTxData(<AccessListEIP2930TxData>txData, txOptions)\n      } else if (txType === 2) {\n        return FeeMarketEIP1559Transaction.fromTxData(<FeeMarketEIP1559TxData>txData, txOptions)\n      } else {\n        throw new Error(`Tx instantiation with type ${txType} not supported`)\n      }\n    }\n  }\n\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Buffer\n   * @param txOptions - The transaction options\n   */\n  public static fromSerializedData(data: Buffer, txOptions: TxOptions = {}): TypedTransaction {\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      switch (data[0]) {\n        case 1:\n          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions)\n        case 2:\n          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions)\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`)\n      }\n    } else {\n      return Transaction.fromSerializedTx(data, txOptions)\n    }\n  }\n\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Buffer[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Buffer or Buffer[]\n   * @param txOptions - The transaction options\n   */\n  public static fromBlockBodyData(data: Buffer | Buffer[], txOptions: TxOptions = {}) {\n    if (Buffer.isBuffer(data)) {\n      return this.fromSerializedData(data, txOptions)\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return Transaction.fromValuesArray(data, txOptions)\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input')\n    }\n  }\n\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - An Ethers JsonRPCProvider\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n  public static async fromEthersProvider(\n    provider: string | any,\n    txHash: string,\n    txOptions?: TxOptions\n  ) {\n    const prov = getProvider(provider)\n    const txData = await fetchFromProvider(prov, {\n      method: 'eth_getTransactionByHash',\n      params: [txHash],\n    })\n    if (txData === null) {\n      throw new Error('No data returned from provider')\n    }\n    return TransactionFactory.fromRPCTx(txData, txOptions)\n  }\n\n  /**\n   * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`\n   * Note that this normalizes some of the parameters\n   * @param txData The RPC-encoded data\n   * @param txOptions The transaction options\n   * @returns\n   */\n  public static async fromRPCTx(\n    txData: TxData | AccessListEIP2930TxData | FeeMarketEIP1559TxData,\n    txOptions: TxOptions = {}\n  ) {\n    return TransactionFactory.fromTxData(normalizeTxParams(txData), txOptions)\n  }\n}\n","import type { FeeMarketEIP1559Transaction } from './eip1559Transaction'\nimport type { AccessListEIP2930Transaction } from './eip2930Transaction'\nimport type { Transaction } from './legacyTransaction'\nimport type { Common } from '@ethereumjs/common'\nimport type { AddressLike, BigIntLike, BufferLike, PrefixedHexString } from '@ethereumjs/util'\n\n/**\n * Can be used in conjunction with {@link Transaction.supports}\n * to query on tx capabilities\n */\nexport enum Capability {\n  /**\n   * Tx supports EIP-155 replay protection\n   * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP\n   */\n  EIP155ReplayProtection = 155,\n\n  /**\n   * Tx supports EIP-1559 gas fee market mechanism\n   * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP\n   */\n  EIP1559FeeMarket = 1559,\n\n  /**\n   * Tx is a typed transaction as defined in EIP-2718\n   * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP\n   */\n  EIP2718TypedTransaction = 2718,\n\n  /**\n   * Tx supports access list generation as defined in EIP-2930\n   * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP\n   */\n  EIP2930AccessLists = 2930,\n}\n\n/**\n * The options for initializing a {@link Transaction}.\n */\nexport interface TxOptions {\n  /**\n   * A {@link Common} object defining the chain and hardfork for the transaction.\n   *\n   * Object will be internally copied so that tx behavior don't incidentally\n   * change on future HF changes.\n   *\n   * Default: {@link Common} object set to `mainnet` and the default hardfork as defined in the {@link Common} class.\n   *\n   * Current default hardfork: `istanbul`\n   */\n  common?: Common\n  /**\n   * A transaction object by default gets frozen along initialization. This gives you\n   * strong additional security guarantees on the consistency of the tx parameters.\n   * It also enables tx hash caching when the `hash()` method is called multiple times.\n   *\n   * If you need to deactivate the tx freeze - e.g. because you want to subclass tx and\n   * add additional properties - it is strongly encouraged that you do the freeze yourself\n   * within your code instead.\n   *\n   * Default: true\n   */\n  freeze?: boolean\n\n  /**\n   * Allows unlimited contract code-size init while debugging. This (partially) disables EIP-3860.\n   * Gas cost for initcode size analysis will still be charged. Use with caution.\n   */\n  allowUnlimitedInitCodeSize?: boolean\n}\n\n/*\n * Access List types\n */\n\nexport type AccessListItem = {\n  address: PrefixedHexString\n  storageKeys: PrefixedHexString[]\n}\n\n/*\n * An Access List as a tuple of [address: Buffer, storageKeys: Buffer[]]\n */\nexport type AccessListBufferItem = [Buffer, Buffer[]]\nexport type AccessListBuffer = AccessListBufferItem[]\nexport type AccessList = AccessListItem[]\n\nexport function isAccessListBuffer(\n  input: AccessListBuffer | AccessList\n): input is AccessListBuffer {\n  if (input.length === 0) {\n    return true\n  }\n  const firstItem = input[0]\n  if (Array.isArray(firstItem)) {\n    return true\n  }\n  return false\n}\n\nexport function isAccessList(input: AccessListBuffer | AccessList): input is AccessList {\n  return !isAccessListBuffer(input) // This is exactly the same method, except the output is negated.\n}\n\n/**\n * Encompassing type for all transaction types.\n *\n * Note that this also includes legacy txs which are\n * referenced as {@link Transaction} for compatibility reasons.\n */\nexport type TypedTransaction =\n  | Transaction\n  | AccessListEIP2930Transaction\n  | FeeMarketEIP1559Transaction\n\n/**\n * Legacy {@link Transaction} Data\n */\nexport type TxData = {\n  /**\n   * The transaction's nonce.\n   */\n  nonce?: BigIntLike\n\n  /**\n   * The transaction's gas price.\n   */\n  gasPrice?: BigIntLike | null\n\n  /**\n   * The transaction's gas limit.\n   */\n  gasLimit?: BigIntLike\n\n  /**\n   * The transaction's the address is sent to.\n   */\n  to?: AddressLike\n\n  /**\n   * The amount of Ether sent.\n   */\n  value?: BigIntLike\n\n  /**\n   * This will contain the data of the message or the init of a contract.\n   */\n  data?: BufferLike\n\n  /**\n   * EC recovery ID.\n   */\n  v?: BigIntLike\n\n  /**\n   * EC signature parameter.\n   */\n  r?: BigIntLike\n\n  /**\n   * EC signature parameter.\n   */\n  s?: BigIntLike\n\n  /**\n   * The transaction type\n   */\n\n  type?: BigIntLike\n}\n\n/**\n * {@link AccessListEIP2930Transaction} data.\n */\nexport interface AccessListEIP2930TxData extends TxData {\n  /**\n   * The transaction's chain ID\n   */\n  chainId?: BigIntLike\n\n  /**\n   * The access list which contains the addresses/storage slots which the transaction wishes to access\n   */\n  accessList?: AccessListBuffer | AccessList | null\n}\n\n/**\n * {@link FeeMarketEIP1559Transaction} data.\n */\nexport interface FeeMarketEIP1559TxData extends AccessListEIP2930TxData {\n  /**\n   * The transaction's gas price, inherited from {@link Transaction}.  This property is not used for EIP1559\n   * transactions and should always be undefined for this specific transaction type.\n   */\n  gasPrice?: never | null\n  /**\n   * The maximum inclusion fee per gas (this fee is given to the miner)\n   */\n  maxPriorityFeePerGas?: BigIntLike\n  /**\n   * The maximum total fee\n   */\n  maxFeePerGas?: BigIntLike\n}\n\n/**\n * Buffer values array for a legacy {@link Transaction}\n */\nexport type TxValuesArray = Buffer[]\n\n/**\n * Buffer values array for an {@link AccessListEIP2930Transaction}\n */\nexport type AccessListEIP2930ValuesArray = [\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  AccessListBuffer,\n  Buffer?,\n  Buffer?,\n  Buffer?\n]\n\n/**\n * Buffer values array for a {@link FeeMarketEIP1559Transaction}\n */\nexport type FeeMarketEIP1559ValuesArray = [\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  Buffer,\n  AccessListBuffer,\n  Buffer?,\n  Buffer?,\n  Buffer?\n]\n\ntype JsonAccessListItem = { address: string; storageKeys: string[] }\n\n/**\n * Generic interface for all tx types with a\n * JSON representation of a transaction.\n *\n * Note that all values are marked as optional\n * and not all the values are present on all tx types\n * (an EIP1559 tx e.g. lacks a `gasPrice`).\n */\nexport interface JsonTx {\n  nonce?: string\n  gasPrice?: string\n  gasLimit?: string\n  to?: string\n  data?: string\n  v?: string\n  r?: string\n  s?: string\n  value?: string\n  chainId?: string\n  accessList?: JsonAccessListItem[]\n  type?: string\n  maxPriorityFeePerGas?: string\n  maxFeePerGas?: string\n  maxFeePerDataGas?: string\n  versionedHashes?: string[]\n}\n\n/*\n * Based on https://ethereum.org/en/developers/docs/apis/json-rpc/\n */\nexport interface JsonRpcTx {\n  blockHash: string | null // DATA, 32 Bytes - hash of the block where this transaction was in. null when it's pending.\n  blockNumber: string | null // QUANTITY - block number where this transaction was in. null when it's pending.\n  from: string // DATA, 20 Bytes - address of the sender.\n  gas: string // QUANTITY - gas provided by the sender.\n  gasPrice: string // QUANTITY - gas price provided by the sender in wei. If EIP-1559 tx, defaults to maxFeePerGas.\n  maxFeePerGas?: string // QUANTITY - max total fee per gas provided by the sender in wei.\n  maxPriorityFeePerGas?: string // QUANTITY - max priority fee per gas provided by the sender in wei.\n  type: string // QUANTITY - EIP-2718 Typed Transaction type\n  accessList?: JsonTx['accessList'] // EIP-2930 access list\n  chainId?: string // Chain ID that this transaction is valid on.\n  hash: string // DATA, 32 Bytes - hash of the transaction.\n  input: string // DATA - the data send along with the transaction.\n  nonce: string // QUANTITY - the number of transactions made by the sender prior to this one.\n  to: string | null /// DATA, 20 Bytes - address of the receiver. null when it's a contract creation transaction.\n  transactionIndex: string | null // QUANTITY - integer of the transactions index position in the block. null when it's pending.\n  value: string // QUANTITY - value transferred in Wei.\n  v: string // QUANTITY - ECDSA recovery id\n  r: string // DATA, 32 Bytes - ECDSA signature r\n  s: string // DATA, 32 Bytes - ECDSA signature s\n  maxFeePerDataGas?: string // QUANTITY - max data fee for blob transactions\n  versionedHashes?: string[] // DATA - array of 32 byte versioned hashes for blob transactions\n}\n","import { bufferToHex, setLengthLeft, toBuffer } from '@ethereumjs/util'\n\nimport { isAccessList } from './types'\n\nimport type { AccessList, AccessListBuffer, AccessListItem } from './types'\nimport type { Common } from '@ethereumjs/common'\n\nexport function checkMaxInitCodeSize(common: Common, length: number) {\n  const maxInitCodeSize = common.param('vm', 'maxInitCodeSize')\n  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {\n    throw new Error(\n      `the initcode size of this transaction is too large: it is ${length} while the max is ${common.param(\n        'vm',\n        'maxInitCodeSize'\n      )}`\n    )\n  }\n}\n\nexport class AccessLists {\n  public static getAccessListData(accessList: AccessListBuffer | AccessList) {\n    let AccessListJSON\n    let bufferAccessList\n    if (isAccessList(accessList)) {\n      AccessListJSON = accessList\n      const newAccessList: AccessListBuffer = []\n\n      for (let i = 0; i < accessList.length; i++) {\n        const item: AccessListItem = accessList[i]\n        const addressBuffer = toBuffer(item.address)\n        const storageItems: Buffer[] = []\n        for (let index = 0; index < item.storageKeys.length; index++) {\n          storageItems.push(toBuffer(item.storageKeys[index]))\n        }\n        newAccessList.push([addressBuffer, storageItems])\n      }\n      bufferAccessList = newAccessList\n    } else {\n      bufferAccessList = accessList ?? []\n      // build the JSON\n      const json: AccessList = []\n      for (let i = 0; i < bufferAccessList.length; i++) {\n        const data = bufferAccessList[i]\n        const address = bufferToHex(data[0])\n        const storageKeys: string[] = []\n        for (let item = 0; item < data[1].length; item++) {\n          storageKeys.push(bufferToHex(data[1][item]))\n        }\n        const jsonItem: AccessListItem = {\n          address,\n          storageKeys,\n        }\n        json.push(jsonItem)\n      }\n      AccessListJSON = json\n    }\n\n    return {\n      AccessListJSON,\n      accessList: bufferAccessList,\n    }\n  }\n\n  public static verifyAccessList(accessList: AccessListBuffer) {\n    for (let key = 0; key < accessList.length; key++) {\n      const accessListItem = accessList[key]\n      const address = <Buffer>accessListItem[0]\n      const storageSlots = <Buffer[]>accessListItem[1]\n      if ((<any>accessListItem)[2] !== undefined) {\n        throw new Error(\n          'Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.'\n        )\n      }\n      if (address.length !== 20) {\n        throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes')\n      }\n      for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {\n        if (storageSlots[storageSlot].length !== 32) {\n          throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes')\n        }\n      }\n    }\n  }\n\n  public static getAccessListJSON(accessList: AccessListBuffer) {\n    const accessListJSON = []\n    for (let index = 0; index < accessList.length; index++) {\n      const item: any = accessList[index]\n      const JSONItem: any = {\n        address: '0x' + setLengthLeft(<Buffer>item[0], 20).toString('hex'),\n        storageKeys: [],\n      }\n      const storageSlots: Buffer[] = item[1]\n      for (let slot = 0; slot < storageSlots.length; slot++) {\n        const storageSlot = storageSlots[slot]\n        JSONItem.storageKeys.push('0x' + setLengthLeft(storageSlot, 32).toString('hex'))\n      }\n      accessListJSON.push(JSONItem)\n    }\n    return accessListJSON\n  }\n\n  public static getDataFeeEIP2930(accessList: AccessListBuffer, common: Common): number {\n    const accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost')\n    const accessListAddressCost = common.param('gasPrices', 'accessListAddressCost')\n\n    let slots = 0\n    for (let index = 0; index < accessList.length; index++) {\n      const item = accessList[index]\n      const storageSlots = item[1]\n      slots += storageSlots.length\n    }\n\n    const addresses = accessList.length\n    return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost)\n  }\n}\n"],"names":["util_1","require","crc_32_1","events_1","goerli","mainnet","rinkeby","ropsten","sepolia","eips_1","enums_1","hardforks_1","utils_1","Common","EventEmitter","constructor","opts","_opts$customChains","_this$_chainParams$de","super","_eips","this","_customChains","customChains","_chainParams","setChain","chain","DEFAULT_HARDFORK","defaultHardfork","Hardfork","Merge","HARDFORK_CHANGES","hardforks","map","hf","name","_hardfork","undefined","hardfork","setHardfork","eips","setEIPs","custom","chainParamsOrName","_opts$baseChain","arguments","length","baseChain","standardChainParams","_getChainParams","CustomChain","PolygonMainnet","chainId","networkId","PolygonMumbai","ArbitrumRinkebyTestnet","ArbitrumOne","xDaiChain","OptimisticKovan","Berlin","OptimisticEthereum","Error","concat","fromGethGenesis","genesisJson","_ref","_genesisParams$name","genesisHash","mergeForkIdPostMerge","genesisParams","parseGethGenesis","common","setForkHashes","isSupportedChainId","initializedChains","_getInitializedChains","Boolean","toString","required","param","block","existing","hfChanges","emit","getHardforkByBlockNumber","blockNumber","td","timestamp","toType","TypeOutput","BigInt","Number","hfs","filter","ttd","mergeIndex","findIndex","slice","hfIndex","reverse","hfStartIndex","reduce","acc","_hf$timestamp","Math","max","_hf$timestamp2","min","setHardforkByBlockNumber","_getHardfork","eip","EIPs","minHF","gteHardfork","requiredEIPs","elem","includes","isActivatedEIP","topic","value","paramByEIP","paramByHardfork","_value","hfEIPs","valueEIP","v","eipParams","paramByBlock","hardforkIsActiveOnBlock","hfBlock","hardforkBlock","activeOnBlock","hardforkGteHardfork","hardfork1","hardfork2","_hardfork2","posHf1","posHf2","index","_hardfork3","_this$_getHardfork","hardforkTimestamp","_hardfork4","_this$_getHardfork2","eipBlock","hardforkTTD","_hardfork5","_this$_getHardfork3","isHardforkBlock","_hardfork6","nextHardforkBlockOrTimestamp","_hardfork7","_hfs$hfIndex$timestam","_nextHf$timestamp","currHfTimeOrBlock","nextHf","find","_hf$timestamp3","hfTimeOrBlock","nextHfBlock","nextHardforkBlock","_hardfork8","isNextHardforkBlock","_hardfork9","_calcForkHash","hfBuffer","Buffer","alloc","prevBlockOrTime","blockOrTime","hfBlockBuffer","from","padStart","inputBuffer","forkhash","intToBuffer","buf","forkHash","_hardfork10","data","hardforkForForkHash","resArray","_hf$timestamp4","genesis","bootstrapNodes","dnsNetworks","chainName","consensusType","_value2","consensusAlgorithm","_value3","consensusConfig","_ref2","_value4","copy","Object","assign","create","getPrototypeOf","removeAllListeners","names","id","entries","Chain","toLowerCase","chains","exports","ConsensusType","ConsensusAlgorithm","chainstart","homestead","dao","tangerineWhistle","spuriousDragon","byzantium","constantinople","petersburg","istanbul","muirGlacier","berlin","london","shanghai","arrowGlacier","grayGlacier","mergeForkIdTransition","merge","shardingFork","__exportStar","parseGethParams","json","_config$clique$period","_config$clique$epoch","config","difficulty","mixHash","gasLimit","coinbase","baseFeePerGas","extraData","nonce","genesisTimestamp","isHexPrefixed","intToHex","parseInt","stripHexPrefix","formatNonce","eip155Block","eip158Block","params","consensus","clique","type","algorithm","period","blockperiodseconds","epoch","epochlength","ethash","forkMap","Homestead","Dao","TangerineWhistle","SpuriousDragon","Byzantium","Constantinople","Petersburg","Istanbul","MuirGlacier","London","MergeForkIdTransition","postMerge","Shanghai","isTimestamp","ShardingForkDev","forkMapRev","keys","configHardforkNames","key","nameBlock","fork","sort","a","b","_a$block","_b$block","Infinity","_a$timestamp","_b$timestamp","terminalTotalDifficulty","mergeConfig","postMergeIndex","_forkMap$hf$name","splice","push","latestHardfork","unshift","Chainstart","some","field","e","message","common_1","types_1","util_2","txData","_opts$allowUnlimitedI","_opts$common","cache","hash","dataFee","activeCapabilities","DEFAULT_CHAIN","Mainnet","to","r","s","_type","bufferToBigInt","toBuffer","txOptions","toB","vB","rB","sB","Address","_validateCannotExceedMaxInteger","createContract","allowUnlimitedInitCodeSize","_getCommon","checkMaxInitCodeSize","supports","capability","validate","stringError","errors","getBaseFee","isSigned","verifySignature","_validateYParity","msg","_errorMsg","_validateHighS","SECP256K1_ORDER_DIV_2","txFee","fee","getDataFee","toCreationAddress","txCreationFee","txDataZero","txDataNonZero","cost","i","dataLength","ceil","publicKey","getSenderPublicKey","unpadBuffer","getSenderAddress","publicToAddress","sign","privateKey","hackApplied","Capability","EIP155ReplayProtection","msgHash","getMessageToSign","ecsign","tx","_processSignature","indexOf","chainIdBigInt","_common$copy","values","bits","cannotEqual","MAX_UINT64","MAX_INTEGER","_validateNotArray","txDataKeys","Array","isArray","_getSharedErrorPostfix","bufferToHex","postfix","rlp_1","keccak_1","baseTransaction_1","TRANSACTION_TYPE_BUFFER","FeeMarketEIP1559Transaction","BaseTransaction","_opts$freeze","accessList","maxFeePerGas","maxPriorityFeePerGas","accessListData","AccessLists","getAccessListData","AccessListJSON","verifyAccessList","freeze","fromTxData","fromSerializedTx","serialized","equals","arrToBufArr","RLP","decode","fromValuesArray","validateNoLeadingZeroes","getDataFeeEIP2930","isFrozen","getUpfrontCost","baseFee","prio","maxBase","gasPrice","raw","bigIntToUnpaddedBuffer","serialize","base","encode","bufArrToArr","hashMessage","keccak256","getMessageToVerifySignature","ecrecover","toJSON","accessListJSON","getAccessListJSON","bigIntToHex","errorStr","AccessListEIP2930Transaction","Uint8Array","_this$accessList$leng","_this$accessList","_txParams","_txParams$gasLimit","txParams","gas","input","setLengthLeft","eip1559Transaction_1","enumerable","get","eip2930Transaction_1","legacyTransaction_1","Transaction","transactionFactory_1","TransactionFactory","meetsEIP155","_v","chainIdDoubled","_validateTxV","_getMessageToSign","numSub","fromRpc_1","txType","fromSerializedData","fromBlockBodyData","isBuffer","fromEthersProvider","provider","txHash","prov","getProvider","fetchFromProvider","method","fromRPCTx","normalizeTxParams","isAccessListBuffer","firstItem","maxInitCodeSize","bufferAccessList","isAccessList","newAccessList","item","addressBuffer","address","storageItems","storageKeys","jsonItem","accessListItem","storageSlots","storageSlot","JSONItem","slot","accessListStorageKeyCost","accessListAddressCost","slots"],"sourceRoot":""}